CSC485B A4
Xinlu Chen
V00907022

++++++++++++++++++++++++++++++
1. Overview: A description of the design of your compression scheme, including the set of transformations and techniques used, and the relevant parameters for each technique.

CAUSION: should run with eigen installed

It contains:
    README.txt
    input_stream.hpp(given)
    output_stream.hpp(given)
    uvg_common.hpp(functions used for both compressor and decompressor)
    yuv_stream.hpp(given)
    eigen folder(contains eigen library, downloaded online)
    uvid_compress.cpp(the compressor)
    uvid_decompress.cpp(the decompressor)
    Makefile

The command for run:
    tar -zxf uvid.tar.gz
    cd uvid
    make
    ffmpeg -i source_video.y4m -f rawvideo -pixel_format yuv420p - > input_video.raw (generate raw from y4m)
    ./uvid_compress w h medium < input_video.raw > compressed.uvi (w for width, h for height)
    ./uvid_decompress < compressed.uvi > output_video.raw
    ffmpeg -f rawvideo -pixel_format yuv420p -framerate 30 -video_size 352x288 -i - -f yuv4mpegpipe output_video.y4m < output_video.raw (generate y4m from raw)
    (the name of y4m file need edit, the width, height, bitrate need change in different inputfiles)
    Compressed to zip:tar -zcvf uvid.tar.gz uvid/

application needed:
    VLC player to play the .y4m file

The compressor and decompressor use techniques:
    I,P frame
    4:2:0 subsampling
    motion compensation,local search
    DCT,quantization,zigzag
    delta encoding
    unary encoding
    RLE encoding

++++++++++++++++++++++++++++++
2. Features: Implemented A point-form list of the features implemented for marks.

    2.1 Documentation: a "README.txt" file is provided
    2.2 My implementation generates temporally compressed frames (P-frames).
    2.3 My implementation implements motion compensation. The scheme generate motion vectors for each microblocks.
    2.4 When the compressor is used with the "medium" quality preset, 
        the compressed bitstream achieves a compression ratio of at least 12 (compared to the YCbCr input stream)
         or 1 bit per pixel (that is, on frames with width w and height h, the averaged compressed size of a frame,
         including the size of all three subsampled colour planes, is wâ€€h bits), while retaining reasonable image quality.


++++++++++++++++++++++++++++++
3. Architecture: A high level description of the architecture of your implementation, including some informa-
tion about the algorithms and data structures used.

General:
    DEFINITION: 
        default order in microblocks/matrix: up to down, left to right
        microblock: 8*8 eigen matrix
        macroblock: 2*2 microblock
        frame: 2d array of microblocks
        motion vector: for each macroblock, it have 1 motion vector
        rle array: 1d array of (value, count) pair.(for use of Pframe encoding)

    Set first frame as I frame, the remaining frames are all P frames. (To save space)
    The P frame could be generated by the previous frame in the decompressor.

    For I frame and P frame, they both need to do the DCT,quantization,zigzag,deltaEncoding, same as A3.
    Added RLE encoding after delta Encoding. The format is a list of pair value. The first element in pair is the value, and the second element in pair represent how many continuous current value appeared in the encoded data.

    After that is the output stream process for Y,Cb,Cr.

    The P frame have extra process before the DCT, 
    it calculates the motion vectors, decode the previous frame, use these information and output the predicted macroblock to the DCT process.
    predicted macroblock(i,j) = (previous macroblock(i+motionvector_x,j+motionvector_y)).
    For the motion vector, motion vector = index of min AAD microblock in previous frame - index of current microblock
    For the AAD calculation, it uses the local search to find the min AAD microblock in previous.
    For local search, In the same index microblock in the previous frame, It compares the surrounding microblocks in previous with current microblock and find the min AAD to form the motion vector.
    Motion compensation use the calculated motion vector,current frame,previous frame to output the predicted frame.

    Not all microblocks need a motion vector, if its Predicted microblock, there exists a value that is higher than 100, it will use the origin value for that microblocks. To prevent the predicted microblocks need more space then origin.


DCT,quantization,zigzag:
    This process is same as the assignment 3

Local search:
    For every microblock(8*8), calculate the average Sum absolute difference(SAD)
    compared with all the surrounding microblocks. Get the index of min AAD microblock.

Motion compensation:
    calculate the motion vectors based on motion vector = index of min AAD microblock prev - index of current microblock
    

Calculating previous frame:
    do the same thing the decompressor does to get the previous frame to reduce rounding error

4:2:0 subsampling:
    The input is in 4:2:0 format (.raw)
    Reduce the space used for Cb,Cr element

Delta encoding:
    After DCT, Do the delta to make the data with smaller Documentation

Unary encoding:
    As I have done the delta encoding, it is benefit to use unary to reduce the duplication of the values.

Conclusion:
    The compression work well, but has some artifact(black dots) in moving scene videos. It is caused by the DCT,quantization.
    May need to change the quantization table to reduce aritifact.

++++++++++++++++++++++++++++++
4. Bitstream: A description of your bitstream format, with enough detail that an outside reader can understand
the structure of your data files.

The bitstream writes each frame information in sequence.
In each frame,
    The bitstream writes height,width of the frame in 1 byte for each, and also a 2 bits quality value(0 for low, 1 for medium, 2 for high).
    Then it pushes a 1 bit value to determine whether it is I frame or P frame.(0 means Pframe, 1 means Iframe);
    It will stream out Y,Cb,Cr information in order.(More detailed below)
    
    If current frame is in P frame: Pushes 1 bit for each microblock,1 means no motion vector needed, 0 otherwise.Then the generated motion vector will be pushed if required.
    The motion vector is a pair value, it will push 1 bit to see the value is postive or negative, 1 for negative,0 otherwise. Then is the absolute motion vector. Do the same process for the first and second motion vector inside the pair.
    If current frame is not in P frame, no motion vectors needed to push.
    
    In both I,P frames, the encoded RLE value will be pushed directly after the motion vectors pushed if required.
    The format: the uanry representation of how many bits are needed to represent the size of the rle list.
                Then push the rle size in the requested bits.
                The rle is a pair value. Similar to motion vector, 1 bit first to represent the positive or negative.
                Then a unary value for bits needed for the value. Then the value is pushed in requested bits.
    rle example: (1,3) means 111, 1 occur 3 continuous time.
    unary example: encode rle size 5: 1110 needs 3 bits. 110 means 5. So 5 is encoded as 1110110.
    value example: encode value -5. 1 means negative. 1110 needs 3 bits. 110 means 5. So -5 encoded as 11110110
    Same format for Y,Cb,Cr as above.

At the end, push flag to indicate end of the data.         



++++++++++++++++++++++++++++++
5. Bibliography: Citations

    1. info on command and sample video:
    https://bright.uvic.ca/content/enforced/283064-202305CSC485BA01xA02xCSC578BA01XCO/a4/video_tools.html#org9830fc8

    2. ppt for this course for the use of quantization table.

    3. folder eigen-3.4.0, contains the eigen library for use of eigen matrix
